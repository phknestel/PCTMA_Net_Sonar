import os
import numpy as np
import pandas as pd
import open3d as o3d
from scipy.spatial import KDTree

# Parameters
output_dir = "alldataset_noPretrain_noHyper_noDenoise_delInput"
csv_results_dir = "csv_results/"
distance_threshold = 0.02  # Assuming meters, equivalent to 20 mm
results = []

def compute_bidirectional_fscore(source_points, target_points, threshold):
    # Build KD-trees for both point clouds
    source_tree = KDTree(source_points)
    target_tree = KDTree(target_points)
    
    # Query for closest points
    _, idx_source_to_target = source_tree.query(target_points, k=1, distance_upper_bound=threshold)
    _, idx_target_to_source = target_tree.query(source_points, k=1, distance_upper_bound=threshold)
    
    # Calculate precision and recall
    precision_source_to_target = np.sum(idx_target_to_source != np.inf) / len(source_points)
    recall_source_to_target = np.sum(idx_source_to_target != np.inf) / len(target_points)
    
    # F-Score for source to target
    if precision_source_to_target + recall_source_to_target > 0:
        fscore_source_to_target = 2 * (precision_source_to_target * recall_source_to_target) / (precision_source_to_target + recall_source_to_target)
    else:
        fscore_source_to_target = 0
    
    # Swap roles for target to source
    precision_target_to_source = np.sum(idx_source_to_target != np.inf) / len(target_points)
    recall_target_to_source = np.sum(idx_target_to_source != np.inf) / len(source_points)
    
    # F-Score for target to source
    if precision_target_to_source + recall_target_to_source > 0:
        fscore_target_to_source = 2 * (precision_target_to_source * recall_target_to_source) / (precision_target_to_source + recall_target_to_source)
    else:
        fscore_target_to_source = 0
    
    return fscore_source_to_target * 100, fscore_target_to_source * 100

# Ensure the CSV results directory exists
os.makedirs(csv_results_dir, exist_ok=True)

for base_name in os.listdir(output_dir):
    if base_name.endswith("_gt.ply"):
        gt_file = os.path.join(output_dir, base_name)
        completed_file = os.path.join(output_dir, f"{base_name.split('_gt')[0]}_pc_recon_denoised.ply")

        # Print statement indicating which files are being compared
        print(f"Comparing GT file: {gt_file} with completed file: {completed_file} and vice versa")

        # Load point clouds
        gt_cloud = o3d.io.read_point_cloud(gt_file)
        completed_cloud = o3d.io.read_point_cloud(completed_file)

        # Convert Open3D PointClouds to numpy arrays
        gt_points = np.asarray(gt_cloud.points)
        completed_points = np.asarray(completed_cloud.points)

        # Compute bidirectional F-Score
        fscore_gt_to_completed, fscore_completed_to_gt = compute_bidirectional_fscore(gt_points, completed_points, distance_threshold)
        
        # Store the results
        results.append({
            "base_name": base_name,
            "Fscore_GT_to_Completed": fscore_gt_to_completed,
            "Fscore_Completed_to_GT": fscore_completed_to_gt
        })

# Convert results to a DataFrame and calculate means
df = pd.DataFrame(results)
mean_fscore_gt_to_completed = df["Fscore_GT_to_Completed"].mean()
mean_fscore_completed_to_gt = df["Fscore_Completed_to_GT"].mean()

# Append means to the DataFrame
mean_row = pd.DataFrame([{
    "base_name": "mean_fscore",
    "Fscore_GT_to_Completed": mean_fscore_gt_to_completed,
    "Fscore_Completed_to_GT": mean_fscore_completed_to_gt
}])
df = pd.concat([df, mean_row], ignore_index=True)

# Save the DataFrame with bidirectional F-Scores to a CSV file
results_filename = f"point_cloud_bidirectional_fscore_results_{output_dir}.csv"
df.to_csv(os.path.join(csv_results_dir, results_filename), index=False)

print(f"Completed. Bidirectional F-Score results, including means, are saved in the CSV file: {results_filename}.")
